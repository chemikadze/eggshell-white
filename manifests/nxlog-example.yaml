# requires environtment policy:
#   action: logging
#   value:  logstash-host

launch:
    parameters:
        logger-num: # for test purposes
            description: Number of loggers
            type: int
            default: 2

    steps:

        - provision-vm:
              action: provisionVmsWithLogging
              phase: provision-vm
              parameters:
                  quantity: "{$.logger-num}"
                  hardwareId: "m1.small"
                  roleName: logger
                  vmIdentity: ec2-user
                  imageId: us-east-1/ami-3ecd1e57
              output:
                loggerips: ips
                instance-dashboard: instance-dashboard

        - do-something:
              action: do-something
              precedingPhases: [ provision-vm ]
              parameters: {}

    return:
        vms:
            description: VMs
            value: "{$.loggerips}"
        # ADD TO YOUR MANIFEST this return value should present to get rendered widget with link
        kibana-instance-dashboard:
            description: Logging Dashboard for instance
            value: "{$.instance-dashboard}"

do-something:
    parameters:
        command:
          type: string
          default: 'echo "Hello from execrun!"'
          description: "Command to execute"
    steps:
        - run-command:
            action: execrun
            phase: "run-command"
            precedingPhases: [  ]
            parameters:
              roles: [ logger ]
              command:
                - "{$.command}"
            output:
              stdout: stdout
              stderr: stderr
    return:
      stdout:
        value: "{$.stdout}"
      stderr:
        value: "{$.stderr}"


do-empty-chef-run:
    parameters:
        logger-cookbooks-version:
          type: string
          default: "stable"

    steps:
        - dummy-chefrun:
            action: chefsolo
            phase: "dummy-chefrun"
            precedingPhases: [ ]
            parameters:
              roles: [ logger ]
              recipeUrl: "http://qubell-logging.s3.amazonaws.com/{$.logger-cookbooks-version}/nxlog.tar.gz"
              runList: [ ]
              jattrs: {}
            output:
              chefState: chefState
    return:
        chefState:
          value: "{$.chefState}"


destroy:
    steps:
    - destroy-vm:
        action: undeployEnv
        parameters:
            phase: destroy





















###################################
# REUSABLE WORKFLOW CANDIDATES
###################################

provisionVmsWithLogging:
    parameters:
        retryCount:
          type: int
          default: 0
          min: 0
        roleName:
          type: string
          default: "default"
          length: {min: 1}
        hardwareId:
          type: string
          length: {min: 1}
        imageId:
          type: string
          default: ""
        quantity:
          type: int
          min: 1
          default: 1
        targetQuantity:
          type: int
          default: -1
        instanceId:
          type: string
          default: ""
        staticIps:
          default: ""
        # This parameter is obsolete. Use "staticIps" instead.
        ip:
          type: string
          default: ""
        jcloudsProvider:
          type: string
          length: {min: 1}
          default: "stub"
        jcloudsEndpoint:
          type: string
          length: {min: 1}
          default: "stub"
        jcloudsIdentity:
          type: string
          length: {min: 1}
          default: "stub"
        jcloudsCredential:
          type: string
          length: {min: 1}
          default: "stub"
        jcloudsNodeNamePrefix:
          type: string
          length: {min: 1}
          default: "GN"
        jcloudsRegions:
          type: string
          default: ""
        # parameters ec2SecurityGroup and subnetId are mutual exclusive.
        # If subnetId is set ec2SecurityGroup is ignored.
        ec2SecurityGroup:
          type: string
          default: "default"
        subnetId:
          type: string
          default: ""
        vmIdentity:
          type: string
          default: "root"
        vmPassword:
          type: string
          default: ""
        vmCredentialResource:
          type: string
          default: "/environments/undeploy-me.pem"
          length: {min: 1}
        useSecureCredentialsStore:
          type: bool
          default: false
        providerSettings:
          type: map
          default: {}


    steps:

        - wrapped-provision-vms:
              action: provisionVms
              phase: provision
              parameters:
                  retryCount: "{$.retryCount}"
                  instanceId: "{$.instanceId}"
                  ip: "{$.ip}"
                  targetQuantity: "{$.targetQuantity}"
                  imageId: "{$.imageId}"
                  jcloudsRegions: "{$.jcloudsRegions}"
                  subnetId: "{$.subnetId}"
                  vmIdentity: "{$.vmIdentity}"
                  hardwareId: "{$.hardwareId}"
                  providerSettings: "{$.providerSettings}"
                  jcloudsIdentity: "{$.jcloudsIdentity}"
                  jcloudsCredential: "{$.jcloudsCredential}"
                  vmPassword: "{$.vmPassword}"
                  useSecureCredentialsStore: "{$.useSecureCredentialsStore}"
                  jcloudsProvider: "{$.jcloudsProvider}"
                  staticIps: "{$.staticIps}"
                  jcloudsNodeNamePrefix: "{$.jcloudsNodeNamePrefix}"
                  ec2SecurityGroup: "{$.ec2SecurityGroup}"
                  vmCredentialResource: "{$.vmCredentialResource}"
                  roleName: "{$.roleName}"
                  jcloudsEndpoint: "{$.jcloudsEndpoint}"
                  quantity: "{$.quantity}"
              output:
                ips: ips
                privateips: privateips

        - enable-logging:
            action: enableLogging
            phase: enable-logging
            precedingPhases: [ provision ]
            parameters:
              roles: [ '{$.roleName}' ]
            output:
              instance-dashboard: instance-dashboard

    return:
        ips:
          value: "{$.ips}"
        privateips:
          value: "{$.privateips}"
        instance-dashboard:
          value: "{$.instance-dashboard}"

enableLogging:
    parameters:
        roles:
          description: "List of roles to install and configure nxlog"
          type: list

    steps:

        - resolve-logger:
            action: logging
            output:
              logger-host: logger-host
              logger-repo: logger-repo
              cookbooks-version: cookbooks-version

        - start-logger:
            action: execrun
            precedingPhases: [resolve-logger]
            parameters:
              roles: '{$.roles}'
              command:
                - |
                    curl -Lkso ~/.undeploy.me/nxlogmanage.sh {$.logger-repo}/{$.cookbooks-version}/setup-nxlog.sh
                    chmod a+x ~/.undeploy.me/nxlogmanage.sh
                    _INSTANCE_ID=$$(basename $$(dirname $$OUTPUT_DIR)) # TODO: hack!
                    NXLOG_RELEASE={$.cookbooks-version} NXLOG_REPO={$.logger-repo} ~/.undeploy.me/nxlogmanage.sh install {$.logger-host} ~/.undeploy.me/$$_INSTANCE_ID $$_INSTANCE_ID

    return:
        instance-dashboard:
          value: "http://{$.logger-host}/kibana/index.html#/dashboard/file/logstash.json"

disableLogging:
    parameters:
        roles:
          description: "List of roles to install and configure nxlog"
          type: list

    steps:

        - resolve-logger:
            action: logging
            output:
              logger-host: logger-host
              cookbooks-version: cookbooks-version

        - cleanup-registry:
            action: execrun
            precedingPhases: [resolve-logger]
            parameters:
              roles: '{$.roles}'
              command:
                - '~/.undeploy.me/nxlogmanage.sh deregister_path --apply-now "$$(basename $$(dirname $$OUTPUT_DIR))"'

registerLogPath:
    parameters:
        roles: {type: list}
        paths: {type: list}
    steps:

        - resolve-logger:
            action: logging
            output:
              logger-host: logger-host
              cookbooks-version: cookbooks-version

        - register-path:
            action: execrun
            precedingPhases: [resolve-logger]
            parameters:
              roles: '{$.roles}'
              command:
                - '~/.undeploy.me/nxlogmanage.sh register_user_path --apply-now "$$(basename $$(dirname $$OUTPUT_DIR))" "{$.logger-host}"'
              args: '{$.paths}'

deregisterLogPath:
    parameters:
        roles: {type: list}
        paths: {type: list}
    steps:

        - resolve-logger:
            action: logging
            output:
              logger-host: logger-host
              cookbooks-version: cookbooks-version

        - deregister-path:
            action: execrun
            precedingPhases: [resolve-logger]
            parameters:
              roles: '{$.roles}'
              command:
                - '~/.undeploy.me/nxlogmanage.sh deregister_path --apply-now "$$(basename $$(dirname $$OUTPUT_DIR))" "{$.logger-host}"'
              args: '{$.paths}'

logging:
    parameters:
        logstash-host: {type: string, default: "localhost"}
        nxlog-repo: {type: string, default: "http://qubell-logging.s3.amazonaws.com"}
        cookbooks-version: {type: string, default: "stable"}
    steps:

        - get-properties:
            action: getEnvironmentProperties
            output:
              props: result

        - compute-properties:
            action: serialize
            precedingPhases: [get-properties]
            parameters:
              format: JSON
              input: [
                '{$.props}',
                {"logstash-host": '{$.logstash-host}'},
                {"nxlog-repo": '{$.nxlog-repo}'}
              ]
            output:
              property-or-policy: serialized

        - choose-logger:
            action: serialize
            precedingPhases: [compute-properties]
            parameters:
              format: JSON
              input: '{$.property-or-policy..logstash-host}'
            output:
              logstash-hosts: serialized

        - choose-repo:
            action: serialize
            precedingPhases: [compute-properties]
            parameters:
              format: JSON
              input: '{$.property-or-policy..nxlog-repo}'
            output:
              nxlog-repos: serialized

    return:
        logger-host:
          value: '{$.logstash-hosts[0]}'
        logger-repo:
          value: '{$.nxlog-repos[0]}'
        cookbooks-version:
          value: '{$.cookbooks-version}'